<template>
  <stack class="ruler-wrapper">
    <!-- 底层 Canvas 绘制刻度 -->
    <canvas id="rulerCanvas" class="ruler-canvas"></canvas>

    <!-- 中间指针 (固定不动) -->
    <div class="pointer-container">
      <image class="pointer-img" src="/pkg_other/assets/img/zhishi.png"></image>
    </div>

    <!-- 顶层透明触摸层 -->
    <div
      class="touch-layer"
      ontouchstart="onTouchStart"
      ontouchmove="onTouchMove"
      ontouchend="onTouchEnd"
      ontouchcancel="onTouchEnd"
    ></div>
  </stack>
</template>

<script>
export default {
  props: {
    min: {
      default: 0
    },
    max: {
      default: 100
    },
    value: {
      default: 50
    },
    unitText: {
      default: ''
    }
  },
  data: {
    itemWidth: 3,
    canvasWidth: 250,
    canvasHeight: 46,
    halfWidth: 125,
    ctx: null,
    scrollOffset: 0,
    touchStartX: 0,
    lastTouchX: 0,
    lastMoveTime: 0,
    velocity: 0,
    animationTimer: null,
    isReady: false,
    _lastValue: null
  },
  computed: {
    maxScrollOffset() {
      return (this.max - this.min) * this.itemWidth
    }
  },
  onInit() {
    this.canvasWidth = 250
    this.halfWidth = this.canvasWidth / 2
  },
  onReady() {
    setTimeout(() => {
      this.initCanvas()
      this.scrollToValue(this.value)
      this.isReady = true
    }, 100)
  },
  initCanvas() {
    const canvas = this.$element('rulerCanvas')
    if (!canvas || !canvas.getContext) {
      console.warn('Canvas not ready')
      return
    }
    this.ctx = canvas.getContext('2d')
    canvas.width = this.canvasWidth
    canvas.height = this.canvasHeight
    this.draw()
  },
  scrollToValue(val) {
    val = Math.max(this.min, Math.min(this.max, val))
    this.scrollOffset = (val - this.min) * this.itemWidth
    this.draw()
    this.emitValue()
  },
  onTouchStart(e) {
    this.stopAnimation()
    const touch = e.touches[0]
    this.touchStartX = touch.clientX
    this.lastTouchX = touch.clientX
    this.lastMoveTime = Date.now()
    this.velocity = 0
  },
  onTouchMove(e) {
    const touch = e.touches[0]
    const currentX = touch.clientX
    const deltaX = this.lastTouchX - currentX
    const now = Date.now()
    const dt = now - this.lastMoveTime

    if (dt > 0) {
      this.velocity = deltaX / dt
    }

    this.lastTouchX = currentX
    this.lastMoveTime = now

    let newOffset = this.scrollOffset + deltaX
    newOffset = Math.max(0, Math.min(this.maxScrollOffset, newOffset))
    this.scrollOffset = newOffset

    this.draw()
    this.emitValue()
  },
  onTouchEnd(e) {
    if (Math.abs(this.velocity) > 0.3) {
      this.startInertia()
    } else {
      this.snapToTick()
    }
  },
  stopAnimation() {
    if (this.animationTimer) {
      clearInterval(this.animationTimer)
      this.animationTimer = null
    }
  },
  startInertia() {
    const friction = 0.92
    const minVelocity = 0.05

    this.animationTimer = setInterval(() => {
      this.velocity *= friction

      if (Math.abs(this.velocity) < minVelocity) {
        this.stopAnimation()
        this.snapToTick()
        return
      }

      let newOffset = this.scrollOffset + this.velocity * 16
      newOffset = Math.max(0, Math.min(this.maxScrollOffset, newOffset))
      this.scrollOffset = newOffset

      this.draw()
      this.emitValue()
    }, 16)
  },
  snapToTick() {
    const ticks = Math.round(this.scrollOffset / this.itemWidth)
    this.scrollOffset = Math.max(
      0,
      Math.min(this.maxScrollOffset, ticks * this.itemWidth)
    )
    this.draw()
    this.emitValue()
  },
  emitValue() {
    const ticks = Math.round(this.scrollOffset / this.itemWidth)
    let val = this.min + ticks
    val = Math.max(this.min, Math.min(this.max, val))

    if (val !== this._lastValue) {
      this._lastValue = val
      this.$emit('change', { value: val })
    }
  },
  draw() {
    if (!this.ctx) return

    const ctx = this.ctx
    const w = this.canvasWidth
    const h = this.canvasHeight
    const scrollL = this.scrollOffset

    ctx.clearRect(0, 0, w, h)

    ctx.textAlign = 'center'
    ctx.textBaseline = 'top'
    ctx.font = 'bold 7px sans-serif'

    // 增加足够多的虚拟刻度，确保左右两边都填满
    const extraTicks = Math.ceil(this.halfWidth / this.itemWidth) + 50

    const startVal =
      this.min + Math.floor((scrollL - this.halfWidth) / this.itemWidth) - 2
    const endVal =
      this.min + Math.ceil((scrollL + w - this.halfWidth) / this.itemWidth) + 2

    // 不限制绘制范围，让两侧都有足够的刻度
    const drawStart = Math.min(this.min - extraTicks, startVal)
    const drawEnd = Math.max(this.max + extraTicks, endVal)

    for (let i = drawStart; i <= drawEnd; i++) {
      const x = this.halfWidth + (i - this.min) * this.itemWidth - scrollL

      if (x < -50 || x > w + 50) continue

      const inRange = i >= this.min && i <= this.max
      const isLong = i % 10 === 0

      ctx.beginPath()

      if (isLong) {
        ctx.strokeStyle = inRange ? '#55cc00' : '#aaddaa'
        ctx.lineWidth = 1
        ctx.moveTo(x, 4)
        ctx.lineTo(x, 20)

        if (inRange) {
          ctx.fillStyle = '#55cc00'
          ctx.fillText(i.toString(), x, 23)
        }
      } else {
        ctx.strokeStyle = inRange ? '#88ff00' : '#cceecc'
        ctx.lineWidth = 1
        ctx.moveTo(x, 4)
        ctx.lineTo(x, 13)
      }
      ctx.stroke()
    }
  }
}
</script>

<style>
.ruler-wrapper {
  width: 100%;
  height: 46px;
}
.ruler-canvas {
  width: 100%;
  height: 46px;
  background-color: rgba(136, 255, 0, 0.08);
}
.pointer-container {
  width: 100%;
  height: 100%;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}
.pointer-img {
  width: 9px;
  height: 23px;
  resize-mode: contain;
  margin-top: -18px;
}
.touch-layer {
  width: 100%;
  height: 100%;
  background-color: transparent;
}
</style>
